// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#include "planarAcoustic.h"
#include "exahype2/RefinementControl.h"

tarch::logging::Log   exahype2::aderdg::acoustic::planarAcoustic::_log( "exahype2::aderdg::acoustic::planarAcoustic" );


/*
 * Enables the usage of shortcuts to access variables, e.g. use Q[s.p] instead of Q[0]
 */
exahype2::aderdg::acoustic::VariableShortcuts s;



double ::exahype2::aderdg::acoustic::planarAcoustic::maxEigenvalue(
  const double* __restrict__ Q, // Q[3+0]
  const tarch::la::Vector<Dimensions,double>&  volumeCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeSize,
  double                                       t,
  double                                       dt,
  int                                          normal
){

  constexpr double K0   = 4.0;
  constexpr double rho  = 1.0;
  constexpr double c = std::sqrt(4.0/rho);

  return c;

}


void ::exahype2::aderdg::acoustic::planarAcoustic::flux(
  const double* __restrict__ Q,
  const tarch::la::Vector<Dimensions,double>&  volumeX,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  double                                       t,
  double                                       dt,
  int                                          normal,
  double* __restrict__ F // F[3]
) {

  constexpr double K0 = 4.0;
  constexpr double rho  = 1.0;

  switch(normal){
    case 0: //flux in x-direction
      F[s.p]    = K0 * Q[s.v+normal];
      F[s.v+0]  = Q[s.p] / rho;
      F[s.v+1]  = 0.0;
      break;
    case 1: //flux in y-direction
      F[s.p]    = K0 * Q[s.v+normal];
      F[s.v+0]  = 0.0;
      F[s.v+1]  = Q[s.p] / rho;
  }

}


void exahype2::aderdg::acoustic::planarAcoustic::initialCondition(
  double * __restrict__ Q, //Q[3+0]
  const tarch::la::Vector<Dimensions,double>&  x,
  const tarch::la::Vector<Dimensions,double>&  h,
  const tarch::la::Vector<Dimensions,int>&     point,
	bool                                         gridIsConstructed
) {

  // simple translation in positive diagonal direction
  const double val = cos( - std::numbers::pi*( x[0] + x[1] ));

  Q[s.v+0] = val;
  Q[s.v+1] = val;

  constexpr double K0  = 4.0;
  constexpr double rho = 1.0;

  //These are defined by the eigenvector of the plane wave operator
  constexpr double kr = std::sqrt(2*K0*rho);
  Q[s.p] = kr*val;

}


void exahype2::aderdg::acoustic::planarAcoustic::boundaryConditions(
  const double * __restrict__                  Qinside, // Qinside[3+0]
  double * __restrict__                        Qoutside, // Qoutside[3+0]
  const tarch::la::Vector<Dimensions,double>&  faceCentre,
  const tarch::la::Vector<Dimensions,double>&  volumeH,
  double                                       t,
  int                                          normal
){

  /*
    Since we are using periodic boundary conditions, this need never be called
  */
  assert(false);

}